#![feature(asm)]
//use std::{error, result};
use delphi::*;

#[cfg(test)]
mod test {
    use super::*;

    #[cfg(all(unix, target_pointer_width = "64"))]
    #[test]
    fn test_fpc_out_bytes_match() {
        let delphi_bin = fpc!(
            br###"
        unit delphi;

        interface

            implementation

            function WF: Integer;
        begin
            While true do
            begin
            end;
        WF:= 1
            end;

        end.
        "###
        );
        static expected_bytes: &[u8] = &[0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x3e, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x9, 0x0, 0x6, 0x0, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x8d, 0x64, 0x24, 0xf0, 0xeb, 0x5, 0xf, 0x1f, 0x44, 0x0, 0x0, 0xeb, 0xfe, 0x66, 0xc7, 0x45, 0xfc, 0x1, 0x0, 0xf, 0xbf, 0x45, 0xfc, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x0];
        assert_eq!(&delphi_bin[..expected_bytes.len()], expected_bytes);
    }

    #[test]
    fn test_fpc_first_function_address_value() {
        let delphi_fn_address = unsafe {
            fpc_first_function_address!(
                br###"
                unit delphi;

                interface

                    implementation

                    function WF: Integer;
                begin
                    While true do
                    begin
                    end;
                WF:= 1
                    end;

                end.
                "###
            )
        };
        assert_eq!(*delphi_fn_address, 0x55);
    }
}
