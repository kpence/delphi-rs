#![feature(asm)]
//use std::{error, result};
use delphi::*;
use lazy_static::lazy_static;
use std::sync::Mutex;

#[cfg(test)]
mod test {
    use super::*;
    lazy_static! {
        static ref DELPHI_RETURN1_FN_ADDRESS: usize = unsafe {
            fpc_first_function_address!(
                br###"
                    unit delphi;

                    interface

                        implementation

                        function ReturnOne: Integer;
                    begin
                        ReturnOne:= 1
                        end;

                    end.
                "###
            ) as usize
        };
    }

    #[cfg(all(unix, target_pointer_width = "64"))]
    #[test]
    fn test_fpc_out_bytes_match() {
        let delphi_bin = fpc!(
            br###"
        unit delphi;

        interface

            implementation

            function WF: Integer;
        begin
            While true do
            begin
            end;
        WF:= 1
            end;

        end.
        "###
        );
        let expected_bytes: &[u8] = &[0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x3e, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x9, 0x0, 0x6, 0x0, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x8d, 0x64, 0x24, 0xf0, 0xeb, 0x5, 0xf, 0x1f, 0x44, 0x0, 0x0, 0xeb, 0xfe, 0x66, 0xc7, 0x45, 0xfc, 0x1, 0x0, 0xf, 0xbf, 0x45, 0xfc, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x0];
        assert_eq!(&delphi_bin[..expected_bytes.len()], expected_bytes);
    }

    #[test]
    fn test_fpc_first_function_address_value() {
        assert_eq!(unsafe { *(*DELPHI_RETURN1_FN_ADDRESS as *const u8) }, 0x55);
    }
}
